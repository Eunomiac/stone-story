

func Set(key, val)
  storage.Set(key, val)
  return val

func Get(key)
  return storage.Get(key)

func Toggle(key)
  Set(key, !Get(key))
  return Get(key)
  
func Cycle(key, vals)
  var curVal = Get(key)
  var index = vals.IndexOf(curVal)
  ?index = vals.Count()
    Set(key, vals[0])
  :
    Set(key, vals[index])

func Reset()
  Set("twoHandedOverride", false)
  Set("weaponOverride", false)
  Set("shieldOverride", false)
 
func breakBuff(buff)
  var buffParts = string.Split(buff, ":")
  buffParts[2] = int.Parse(buffParts[2])
  buffParts[3] = int.Parse(buffParts[3])
  return [buffParts[1], buffParts[2], buffParts[3]]
  
func getBuffParts(buffName, buffString)
  var buffStrings = string.split(buffString, ",")
  for buffStr : buffStrings
    var buffParts = string.Split(buffStr, ":")
    ?Type(buffParts) = Type([]) & buffParts.Count() = 4
      ?string.IndexOf(buffParts[1], buffName) > -1
        return [int.Parse(buffParts[2]), int.Parse(buffParts[3])]
  return [0, 0]

func xLookup(val, arr1, arr2)
  var index = arr1.IndexOf(val)
  ?index > -1
    return arr2[index]
  :
    return false

func getBuffCount(buffName)
  return getBuffParts(buffName, buffs.string)[0]

func getDebuffCount(buffName)
  return getBuffParts(buffName, debuffs.string)[0]
  
func getFoeDebuffCount(buffName)
  return getBuffParts(buffName, foe.debuffs.string)[0]

func getArmor()
  return math.Round((armor * 10) + armor.f) / 10

var ranges = ["melee", "close", "medium", "ranged", "screen"]
var units = [5, 11, 16, 25, 35]

func isCloseAs(range)
  return foe.distance <= xLookup(range, ranges, units)

func isFarAs(range)
  return foe.distance >= xLookup(range, ranges, units)

func isWithin(rangeA, rangeB)
  var unitA = xLookup(rangeA, ranges, units)
  var unitB = xLookup(rangeB, ranges, units)
  return isInRange(unitA, unitB)

func isInRange(min, max)
  ?max > min
    return foe.distance >= min & foe.distance <= max
  :
    return foe.distance >= min

func isInState(stateNum, stateTime)
  return foe.state = stateNum & foe.time >= stateTime

func toSeconds(frameCount)
  return math.Round(frameCount / 3) / 10

var locations = ["Rocky Plateau", "Deadwood Canyon", "Caves of Fear", "Mushroom Forest", "Haunted Halls",  "Boiling Mine", "Icy Ridge", "Temple"]
var locElems = ["none",  "none", "poison", "vigor", "aether", "fire", "ice", "poison"]
var elements = ["none", "poison", "vigor",  "aether", "fire", "ice"]
var counterElements = ["none", "vigor", "aether", "fire", "ice", "poison"]

var potions = ["experience","strength","healing","lightning","invisibility","cleansing","berserk","defensive","lucky","vampiric"]
var ingredients = ["wood + wood", "stone + stone", "tar + tar", "bronze + bronze", "wood + stone", "wood + tar", "wood + bronze", "stone + tar", "stone + bronze", "tar + bronze"]

func getHealingPotion()
  ?res.stone > 1500
    return "defensive"
  :?res.bronze > 1500
    return "vampiric"
  :?res.wood > 1500
    return "cleansing"
  :?res.tar > 3000
    return "healing"
  :?res.stone > res.wood & res.stone > res.bronze
    return "defensive"
  :?res.wood > res.stone & res.wood > res.bronze
    return "cleansing"
  :?res.bronze > res.stone & res.bronze > res.wood
    return "vampiric"
    
func brewPotion(potion)
  var ingred = xLookup(potion, potions, ingredients)
  ?ingred = "wood + wood"
    brew wood + wood
  :?ingred = "stone + stone"
    brew stone + stone
  :?ingred = "tar + tar"
    brew tar + tar
  :?ingred = "bronze + bronze"
    brew bronze + bronze
  :?ingred = "wood + stone"
    brew wood + stone
  :?ingred = "wood + tar"
    brew wood + tar
  :?ingred = "wood + bronze"
    brew wood + bronze
  :?ingred = "stone + tar"
    brew stone + tar
  :?ingred = "stone + bronze"
    brew stone + bronze
  :?ingred = "tar + bronze"
    brew tar + bronze

func displayFoe(startLine, xStart)
  var foeName = foe.name
  var nameIndex = String.IndexOf(foe, foe.name)
  var nameLength = String.Size(foe.name)
  var foeSuffix = String.Sub(foe, nameIndex + nameLength)
  var foeKeywords = String.Split(foeSuffix, true)
  var numRows = Math.CeilToInt(foeKeywords.Count() / 2)
  >`@xStart@,@startLine@,#FF0000,Foe: @foeName@ (+@foe.count@)
  var xOffset = 10
  for i = 0 .. foeKeywords.Count()-1
    ?i % 4 = 0
      startLine++
      >`@xStart+2@,@startLine@,#CC0000,[@foeKeywords[i]@]
      xOffset = String.Size(foeKeywords[i])+3
    :
      >`@xStart+xOffset+2@,@startLine@,#FF0000,[@foeKeywords[i]@]
      xOffset = xOffset + String.Size(foeKeywords[i])+3
  startLine++
  return startLine
  
func isFacingBoss()
  ?isInRange(0, 35)
    ?foe = dysangelos | (loc = deadwood & foe = boss) | foe = bolesh | (loc = mushroom & foe = boss) | foe = pallas | foe = bronze_guardian | foe = hrÃ­mnir | foe = nagaraja
      return true
  return false
 
func isRangedWeapon(itemid)
  return itemid = crossbow | itemid = wand | itemid = talisman | itemid = staff | itemid = ouroboros


var leftItem = item.left
var rightItem = item.right

func storeEquipLeft(itemid)
  ?isLeftLocked()
    return
  ?String.Size(itemid) > 2
    Set("leftItem", itemid)
  :?String.Size(item.left) > 2
    Set("leftItem", item.left)
  :
    Set("leftItem", false)

func storeEquipRight(itemid)
  ?isRightLocked()
    return
  ?String.Size(itemid) > 2
    Set("rightItem", itemid)
  :?String.Size(item.right) > 2
    Set("rightItem", item.right)
  :
    Set("rightItem", false)

func getStoredLeft()
  ?Get("weaponOverride")
    return Get("weaponOverride")
  return Get("leftItem")
func getStoredRight()
  return Get("rightItem")
    
func lockLeft()
  Set("isLeftLocked", true)
func lockLeftUntilAfterState(stateNum)
  Set("isLeftLocked", stateNum)
func unlockLeft()
  Set("isLeftLocked", false)
  
func lockRight()
  Set("isRightLocked", true)
func lockRightUntilAfterState(stateNum)
  Set("isRightLocked", stateNum)
func unlockRight()
  Set("isRightLocked", false)
  
func isLeftLocked()
  ?Get("isLeftLocked") = true | Get("isLeftLocked") = false
    return Get("isLeftLocked")
  return Get("isLeftLocked") < item.left.state
func isRightLocked()
  ?Get("isRightLocked") = true | Get("isRightLocked") = false
    return Get("isRightLocked")
  return Get("isRightLocked") < item.right.state
  
func equipRight(itemid)
  ?isRightLocked()
    equipR @getStoredRight()@
    return

  ?Get("shieldOverride")
    equipRight(Get("shieldOverride"))
    lockRight()
    return

  ?String.Size(itemid) > 2
    storeEquipRight(itemid)
  :?String.Size(item.right) > 2
    storeEquipRight(item.right)

  ?String.Size(getStoredRight()) > 2
    equipR @getStoredRight()@

func equipLeft(itemid)
  ?isLeftLocked()
    equipL @getStoredLeft()@
    equip @getStoredLeft()@
    return

  ?Get("weaponOverride")
    equipLeft(Get("weaponOverride"))
    lockLeft()
    return
  ?Get("twoHandedOverride")    
    equipLeft(Get("twoHandedOverride"))
    lockLeft()
    lockRight()
    return
    
  unlockLeft()

  ?String.Size(itemid) > 2
    storeEquipLeft(itemid)
  :?String.Size(item.left) > 2
    storeEquipLeft(item.left)
    
  var storedLeft = getStoredLeft()

  Set("usingRanged", isRangedWeapon(storedLeft))

  ?String.Size(storedLeft) > 2
    equipL @storedLeft@
    equip @storedLeft@
    
func equipLeftUntilAfterState(itemid, state)
  ?isLeftLocked()
    return
  ?String.Size(itemid) > 2
    equipLeft(itemid)
    lockLeftUntilAfterState(2)     
        
func equipRightUntilAfterState(itemid, state)
  ?isRightLocked()
    return
  ?String.Size(itemid) > 2
    equipRight(itemid)
    lockRightUntilAfterState(2)   
