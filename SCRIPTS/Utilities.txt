// === Cooldown String Reference ===
//     Æther Talisman		"aether_talisman"
//     Bardiche				"bardiche"
//     Bashing Shield		"bash"
//     Blade o/Fallen God	"blade"
//     Cinderwisp Devour	"cinderwisp"
//     Cultist Mask			"mask"
//     Dashing Shield		"dash"
//     Fire Talisman		"fire_talisman"
//     Hatchet				"hatchet"
//     Heavy Hammer			"hammer"
//     Mind Stone			"mind"
//     Quarterstaff			"quarterstaff"
//     Skeleton Arm			"skeleton_arm"
//     Voidweaver Devour	"voidweaver"

// === KEY REFERENCE ===
// 		left		A or ←
// 		right       D or →
// 		up          W or ↑
// 		down        S or ↓
// 		primary     LMB or Return
// 		bumpL       Z
// 		bumpR       C
// 		back        X
// 		ability1    Shift
// 		ability2    Control

func Set(key, val)
  storage.Set(key, val)
  return val

func Get(key)
  return storage.Get(key)

func Toggle(key)
  Set(key, !Get(key))
  return Get(key)
  
func Cycle(key, vals)
  var curVal = Get(key)
  var index = vals.IndexOf(curVal)
  ?index = vals.Count()
    Set(key, vals[0])
  :
    Set(key, vals[index])
    
func Has(key)
  return storage.Has(key)
 
func Init()
  ?!Has("hideHUD")
    Set("hideHUD", false)
  ?!Has("staffSpeed")
    Set("staffSpeed", true)
  ?!Has("skeletonArm")
    Set("skeletonArm", true)
  ?!Has("isRangeBlocked")
    Set("isRangeBlocked", false)
  ?!Has("assignedLeft")
    Set("assignedLeft", false)
    Set("leftReason", "")
    Set("leftPriority", 0)
  ?!Has("assignedBoth")
    Set("assignedBoth", false)
    Set("bothReason", "")
    Set("bothPriority", 0)
  ?!Has("assignedRight")
    Set("assignedRight", false)
    Set("rightReason", "")
    Set("rightPriority", 0)
  ?!Has("isActivating")
    Set("isActivating", false)
  ?!Has("mindFreeze")
    Set("mindFreeze", 0)

func Reset()
  InitLeft()
  InitRight()
  InitBoth()
  Set("isActivating", false)

func ActivateItem()
  ?item.CanActivate()
    activate R
  
func InitLeft()
  var stateWatch = 0
  ?Get("leftPriority") >= 10 // Watching for item state to not equal this/10)
    stateWatch = Get("leftPriority") / 10
    ?item.left & Type(item.left.state) = int & item.left.state = stateWatch
      return    
    :
      Set("leftPriority", 0)
    
  ?Get("leftPriority") < 4
    Set("assignedLeft", false)
    Set("leftReason", "")
    Set("leftPriority", 0)

func InitRight()
  var stateWatch = 0
  ?Get("rightPriority") >= 10 // Watching for item state to not equal this/10)
    stateWatch = Get("rightPriority") / 10
    ?item.right & Type(item.right.state) = int & item.right.state = stateWatch
      return
    :
      Set("rightPriority", 0)
  ?Get("rightPriority") < 4
    Set("assignedRight", false)
    Set("rightReason", "")
    Set("rightPriority", 0)
    
func InitBoth()
  var stateWatch = 0
  ?Get("bothPriority") >= 10 // Watching for item state to not equal this/10)
    stateWatch = Get("bothPriority") / 10
    ?item.left & Type(item.left.state) = int & item.left.state = stateWatch
      return    
    :
      Set("bothPriority", 0)
  ?Get("bothPriority") < 4
    Set("assignedBoth", false)
    Set("bothReason", "")
    Set("bothPriority", 0)

func AssignBoth(item, priority, reason)
  ?priority < 0
    Set("bothPriority", 0)
  :?Get("bothPriority") <= priority & Get("leftPriority") <= priority & Get("rightPriority") <= priority
    Set("assignedBoth", item)
    Set("bothReason", priority + ": " + reason)
    Set("bothPriority", priority)

func AssignLeft(item, priority, reason)
  ?priority < 0
    Set("leftPriority", 0)
  :?isTwoHanded(item)
    AssignBoth(item, priority, reason)
  :?Get("leftPriority") <= priority & Get("bothPriority") <= priority
    Set("assignedLeft", item)
    ?item = mind
      Set("mindFreeze", time)
    Set("leftReason", priority + ": " + reason)
    Set("leftPriority", priority)

func AssignRight(item, priority, reason)
  ?priority < 0
    Set("rightPriority", 0)
  :?Get("rightPriority") <= priority & Get("bothPriority") <= priority
    Set("assignedRight", item)
    Set("rightReason", priority + ": " + reason)
    Set("rightPriority", priority)

func AssignActivate(param)
  Set("isActivating", param)
  
func EquipItems()
  ?Get("assignedRight") ! false
    equipR @Get("assignedRight")@
  ?Get("assignedLeft") ! false
    equipL @Get("assignedLeft")@
  ?Get("assignedBoth") ! false
    equip @Get("assignedBoth")@
 
func breakBuff(buff)
  var buffParts = string.Split(buff, ":")
  buffParts[2] = int.Parse(buffParts[2])
  buffParts[3] = int.Parse(buffParts[3])
  return [buffParts[1], buffParts[2], buffParts[3]]
  
func getBuffParts(buffName, buffString)
  var buffStrings = string.split(buffString, ",")
  for buffStr : buffStrings
    var buffParts = string.Split(buffStr, ":")
    ?Type(buffParts) = Type([]) & buffParts.Count() = 4
      ?string.IndexOf(buffParts[1], buffName) > -1
        return [int.Parse(buffParts[2]), int.Parse(buffParts[3])]
  return [0, 0]

func xLookup(val, arr1, arr2)
  var index = arr1.IndexOf(val)
  ?index > -1
    return arr2[index]
  :
    return false

func getBuffCount(buffName)
  return getBuffParts(buffName, buffs.string)[0]

func getDebuffCount(buffName)
  return getBuffParts(buffName, debuffs.string)[0]
  
func getFoeDebuffCount(buffName)
  return getBuffParts(buffName, foe.debuffs.string)[0]

func getArmor()
  return math.Round((armor * 10) + armor.f) / 10

var ranges = ["melee", "close", "medium", "ranged", "screen"]
var units = [5, 11, 16, 25, 35]

func isCloseAs(range)
  return foe.distance <= (xLookup(range, ranges, units) + 1)

func isFarAs(range)
  return foe.distance >= (xLookup(range, ranges, units) - 1)

func isWithin(rangeA, rangeB)
  var unitA = xLookup(rangeA, ranges, units)
  var unitB = xLookup(rangeB, ranges, units)
  return isInRange(unitA, unitB)

func isInRange(min, max)
  ?max > min
    return foe.distance >= (min - 1) & foe.distance <= (max + 1)
  :
    return foe.distance >= (min - 1)

func isInState(stateNum, stateTime)
  return foe.state = stateNum & foe.time >= stateTime

func canDash()
  ?Get("mindFreeze") = 0 | (time - Get("mindFreeze")) > 30
    Set("mindFreeze", 0)
  :
    return false
  ?isInRange(9, 14) & foe ! explode
    ?item.GetCooldown("bash") <= 0
      return "bash"
    :
      return "dash"
  return false

func toSeconds(frameCount)
  return math.Round(frameCount / 30)

var locations = ["Rocky Plateau", "Deadwood Canyon", "Caves of Fear", "Mushroom Forest", "Haunted Halls",  "Boiling Mine", "Icy Ridge", "Temple"]
var locElems = ["none",  "none", "poison", "vigor", "aether", "fire", "ice", "poison"]
var elements = ["none", "vigor", "aether", "fire", "ice", "poison"]
var counterElements = ["none", "poison", "vigor",  "aether", "fire", "ice"]

func getCounterElement()
  var element = ""
  var counterElement = ""
  var resString = ""
  var elementString = ""
  ?foe.count > 0
    for i = 1..5
      element = elements[i]
      counterElement = counterElements[i]
      resString = string.Join("", ["adaptive_defense_", counterElement])
      elementString = " " + element + " "
      ?foe = elementString & foe.buffs.string ! resString
        return counterElement
  return false
  
var potions = ["experience","strength","healing","lightning","invisibility","cleansing","berserk","defensive","lucky","vampiric"]
var ingredients = ["wood + wood", "stone + stone", "tar + tar", "bronze + bronze", "wood + stone", "wood + tar", "wood + bronze", "stone + tar", "stone + bronze", "tar + bronze"]

func getHealingPotion()
  ?res.stone > 1500
    return "defensive"
  :?res.bronze > 1500
    return "vampiric"
  :?res.wood > 1500
    return "cleansing"
  :?res.tar > 3000
    return "healing"
  :?res.stone > res.wood & res.stone > res.bronze
    return "defensive"
  :?res.wood > res.stone & res.wood > res.bronze
    return "cleansing"
  :?res.bronze > res.stone & res.bronze > res.wood
    return "vampiric"
    
func brewPotion(potion)
  var ingred = xLookup(potion, potions, ingredients)
  ?ingred = "wood + wood"
    brew wood + wood
  :?ingred = "stone + stone"
    brew stone + stone
  :?ingred = "tar + tar"
    brew tar + tar
  :?ingred = "bronze + bronze"
    brew bronze + bronze
  :?ingred = "wood + stone"
    brew wood + stone
  :?ingred = "wood + tar"
    brew wood + tar
  :?ingred = "wood + bronze"
    brew wood + bronze
  :?ingred = "stone + tar"
    brew stone + tar
  :?ingred = "stone + bronze"
    brew stone + bronze
  :?ingred = "tar + bronze"
    brew tar + bronze

func displayFoe(startLine, xStart)
  var foeName = foe.name
  var nameIndex = String.IndexOf(foe, foe.name)
  var nameLength = String.Size(foe.name)
  var foeSuffix = String.Sub(foe, nameIndex + nameLength)
  var foeKeywords = String.Split(foeSuffix, true)
  var numRows = Math.CeilToInt(foeKeywords.Count() / 2)
  >`@xStart@,@startLine@,#FF0000,Foe: @foeName@ (+@foe.count@)
  var xOffset = 10
  for i = 0 .. foeKeywords.Count()-1
    ?i % 4 = 0
      startLine++
      >`@xStart+2@,@startLine@,#CC0000,[@foeKeywords[i]@]
      xOffset = String.Size(foeKeywords[i])+3
    :
      >`@xStart+xOffset+2@,@startLine@,#FF0000,[@foeKeywords[i]@]
      xOffset = xOffset + String.Size(foeKeywords[i])+3
  startLine++
  return startLine
  
func isFacingBoss()
  ?isInRange(0, 35)
    ?foe = dysangelos | (loc = deadwood & foe = boss) | foe = bolesh | (loc = mushroom & foe = boss) | foe = pallas | foe = bronze_guardian | foe = hrímnir | foe = nagaraja
      return true
  return false
 
func isRangedWeapon(itemid)
  return itemid = crossbow | itemid = wand | itemid = talisman | itemid = staff | itemid = ouroboros
func isTwoHanded(itemid)
  return itemid = crossbow | itemid = heavy hammer | itemid = staff | itemid = bardiche | itemid = blade of the fallen god
